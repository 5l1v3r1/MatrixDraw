var bi = (function() {
    function paddZeros(_number, digits) {
        var number = _number;
        while (number.length < digits) {
            number = '0' + number;
        }
        return number;
    }
    
    /**
     * Used for manipulating an array of bits.
     */
    function BitBuffer() {
        this.buffer = new Uint8Array(BitBuffer.baseLength);
        this.bits = 0;
        this.buffer[0] = 0;
    }
    
    BitBuffer.baseLength = 8;

    BitBuffer.prototype.append = function(bitVal) {
        if (this.bits == this.buffer.length * 8) {
            var newBuff = new Uint8Array(this.buffer.length + BitBuffer.baseLength);
            for (var i = 0; i < this.buffer.length; i++) {
                newBuff[i] = this.buffer[i];
            }
            for (var j = this.buffer.length + 1; j < newBuff.length; j++) {
                newBuff[j] = 0;
            }
            newBuff[this.buffer.length] = bitVal ? 1 : 0;
            this.buffer = newBuff;
        } else if (bitVal) {
            var byteIndex = Math.floor(this.bits / 8);
            var byteVal = this.buffer[byteIndex];
        
            var bitIndex = this.bits % 8;
            byteVal |= (1 << bitIndex);
        
            this.buffer[byteIndex] = byteVal;
        }
        this.bits++;
    }

    BitBuffer.prototype.get = function(bitIndex) {
        if (bitIndex >= this.bits) throw new Error('Access out of bounds');
        var byteIndex = Math.floor(bitIndex / 8);
        var bitIndex = bitIndex % 8;
        
        return (this.buffer[byteIndex] & (1 << bitIndex)) != 0;
    }

    BitBuffer.prototype.set = function(bitIndex, flag) {
        if (bitIndex >= this.bits) throw new Error('Access out of bounds');
        var byteIndex = Math.floor(bitIndex / 8);
        var bitIndex = bitIndex % 8;
        if (flag) {
            this.buffer[byteIndex] |= (1 << bitIndex);
        } else {
            this.buffer[byteIndex] &= 0xff ^ (1 << bitIndex);
        }
    }

    BitBuffer.prototype.trimmed = function() {
        var lastOne = 0;
        for (var i = 0; i < this.bits; i++) {
            if (this.get(i)) lastOne = i;
        }
        var result = new BitBuffer();
        for (var i = 0; i <= lastOne; i++) {
            result.append(this.get(i));
        }
        return result;
    }
    
    BitBuffer.prototype.copy = function() {
        var buffer = new BitBuffer();
        for (var i = 0; i < this.bits; i++) {
            buffer.append(this.get(i));
        }
        return buffer;
    }

    function BigInt(buffer, sign) {
        this.buffer = buffer;
        this.sign = sign;
    }

    BigInt.prototype.bitCount = function() {
        return this.buffer.bits;
    }

    BigInt.prototype.neg = function() {
        return new BigInt(this.buffer, !this.sign);
    }

    BigInt.prototype.getBit = function(i) {
        if (i >= this.bitCount()) return false;
        return this.buffer.get(i);
    }
    
    BigInt.prototype.setBit = function(bit, flag) {
        var newBuff = this.buffer.copy();
        if (bit >= newBuff.bits) {
            while (bit > newBuff.bits) {
                newBuff.append(false);
            }
            newBuff.append(flag);
        } else {
            newBuff.set(bit, flag);
        }
        return new BigInt(newBuff.trimmed(), this.sign);
    }

    BigInt.prototype.isGreater = function(a) {
        if (this.isEqual(a)) return false;
        if (a.sign != this.sign) {
            if (this.sign) return true;
            return false;
        }
        if (!a.sign) {
            return a.neg().isGreater(this.neg());
        }
        if (this.bitCount() > a.bitCount()) return true;
        if (this.bitCount() < a.bitCount()) return false;
        // compare from greatest to least
        for (var i = this.bitCount() - 1; i >= 0; i--) {
            var thisVal = this.buffer.get(i);
            var aVal = a.buffer.get(i);
            if (thisVal && !aVal) return true;
            if (!thisVal && aVal) return false;
        }
        return false;
    }

    BigInt.prototype.isEqual = function(a) {
        if (this.bitCount() != a.bitCount()) return false;
        if (this.bitCount() == 0) return true;
        if (this.sign != a.sign) return false;
        for (var i = 0; i < this.bitCount(); i++) {
            if (this.buffer.get(i) != a.buffer.get(i)) {
                return false;
            }
        }
        return true;
    }

    BigInt.prototype.shiftLeft = function(num) {
        // append num zeros
        var buffer = new BitBuffer();
        for (var i = 0; i < num; i++) {
            buffer.append(false);
        }
        for (var i = 0; i < this.bitCount(); i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer, this.sign);
    }
    
    BigInt.prototype.shiftRight = function(num) {
        // append num zeros
        var buffer = new BitBuffer();
        for (var i = num; i < this.bitCount(); i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer, this.sign);
    }

    BigInt.prototype.mul = function(obj) {
        // binary-based multiplication
        var sum = BigInt.zero;
        var thisScale = obj.sign ? this : this.neg();
        for (var i = 0; i < obj.bitCount(); i++) {
            var bitVal = obj.getBit(i);
            if (bitVal) {
                sum = sum.add(thisScale);
            }
            thisScale = thisScale.shiftLeft(1);
        }
        return sum;
    }

    BigInt.prototype.div = function(obj) {
        if (!this.sign) return this.neg().div(obj).neg();
        if (!obj.sign) return this.div(obj.neg()).neg();
        if (obj.isGreater(this)) return BigInt.zero;
        if (obj.bitCount() == 0) throw new Error('Divide by zero exception');
    
        var result = BigInt.zero;
        var product = BigInt.zero;
        // binary search
        for (var digit = this.bitCount() - 1; digit >= 0; digit--) {
            var shiftedObj = obj.shiftLeft(digit);
            var testProduct = product.add(shiftedObj);
            if (!testProduct.isGreater(this)) {
                result = result.setBit(digit, true);
                product = testProduct;
            }
        }
        
        return result;
    }
    
    BigInt.prototype.divMod = function(obj) {
        if (!this.sign) return this.neg().divMod(obj).neg();
        if (!obj.sign) return this.divMod(obj.neg()).neg();
        if (obj.isGreater(this)) return {mod: this, div: BigInt.zero};
    
        var result = BigInt.zero;
        var product = BigInt.zero;
        // binary search
        for (var digit = this.bitCount() - 1; digit >= 0; digit--) {
            var shiftedObj = obj.shiftLeft(digit);
            var testProduct = product.add(shiftedObj);
            if (!testProduct.isGreater(this)) {
                result = result.setBit(digit, true);
                product = testProduct;
            }
        }
        var modulus = this.sub(product);
        return {div: result, mod: modulus};
    }

    BigInt.prototype.add = function(obj) {
        // special cases for sign
        if (this.sign == obj.sign) {
            if (!this.sign) {
                // adding two negative numbers
                return this.neg().add(obj.neg()).neg();
            }
        } else {
            if (this.sign) {
                // adding a negative number
                return this.sub(obj.neg());
            } else {
                // adding to a negative number
                return obj.sub(this.neg());
            }
        }
    
        // primitive positive-positive addition!
        var carry = 0;
        var digitCount = Math.max(this.bitCount(), obj.bitCount());
        var buffer = new BitBuffer();
        for (var i = 0; i <= digitCount; i++) {
            var thisDig = this.getBit(i) ? 1 : 0;
            var objDig = obj.getBit(i) ? 1 : 0;
            var trueCount = thisDig + objDig + carry;
            if (i == digitCount && trueCount == 0) break;
        
            buffer.append(trueCount % 2 ? true : false);
            carry = (trueCount >= 2 ? 1 : 0);
        }
        return new BigInt(buffer, true);
    }

    BigInt.prototype.sub = function(obj) {
        // special cases
        if (this.sign == obj.sign) {
            if (!this.sign) {
                // negative minus negative
                return obj.neg().sub(this.neg());
            }
        } else {
            if (this.sign) {
                // positive minus negative
                return this.add(obj.neg());
            } else {
                // negative minus positive
                return this.neg().add(obj).neg();
            }
        }
        
        // make sure this > obj, otherwise return negative
        // inverse result.
        if (obj.isGreater(this)) return obj.sub(this).neg();
    
        // compute the difference
        var carry = false;
        var digitCount = Math.max(this.bitCount(), obj.bitCount());
        var buffer = new BitBuffer();
        for (var i = 0; i < digitCount; i++) {
            var thisDig = this.getBit(i);
            var objDig = obj.getBit(i);
            if (carry) {
                if (thisDig && !objDig) { // 1 - 0
                    carry = false;
                }
                buffer.append(thisDig == objDig);
            } else {
                if (!thisDig && objDig) {  // 0 - 1
                    carry = true;
                }
                buffer.append(thisDig != objDig);
            }
        }
    
        // trim buffer to biggest digit
        buffer = buffer.trimmed();
        return new BigInt(buffer, true);
    }

    BigInt.prototype.mod = function(value) {
        return this.divMod(value).mod;
    }

    BigInt.prototype.toInt = function() {
        var intVal = 0;
        var mul = 1;
        for (var i = 0; i < this.bitCount(); i++) {
            intVal += (this.getBit(i) ? mul : 0);
            mul *= 2;
        }
        return intVal;
    }

    BigInt.prototype.toString = function() {
        if (!this.sign) {
            return '-' + this.neg().toString();
        }
        var num = this;
        var digitCount = 8;
        var radix = BigInt.fromInt(Math.pow(10, digitCount));
        var string = '';
        while (num.bitCount() > 0) {
            var modDiv = num.divMod(radix);
            num = modDiv.div;
            
            var intStr = modDiv.mod.toInt().toString();
            if (num.bitCount() > 0) {
                intStr = paddZeros(intStr, digitCount);
            }
            string = intStr + string;
        }
        return string.length == 0 ? '0' : string;
    }
    
    BigInt.prototype.binaryString = function() {
        var str = '';
        for (var i = 0; i < this.bitCount(); i++) {
            str = (this.getBit(i) ? '1' : '0') + str;
        }
        return '0b' + (str.length == 0 ? '0' : str);
    }

    BigInt.zero = new BigInt(new BitBuffer(), true);

    BigInt.fromInt = function(_value) {
        var sign = _value >= 0;
        var value = Math.floor(Math.abs(_value));
        var buffer = new BitBuffer();
        while (value > 0) {
            var flag = value % 2;
            buffer.append(flag == 1);
            value >>= 1;
        }
        return new BigInt(buffer, sign);
    }

    BigInt.fromString = function(string) {
        if (string[0] == '-') return BigInt.fromString(string.substring(1)).neg();
        
        var ten = BigInt.fromInt(10);
        var place = BigInt.fromInt(1);
    
        var digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        var result = BigInt.zero;
        for (var i = string.length - 1; i >= 0; i--) {
            var digit = string[i];
            var digitValue = digits.indexOf(digit);
            if (digitValue < 0) throw new Error('Invalid decimal string');
        
            // add 10^n * digit
            var digitNum = BigInt.fromInt(digitValue);
            result = result.add(place.mul(digitNum));
            place = place.mul(ten);
        }
    
        return result;
    }
    return BigInt;
})();

var BigInt = bi;
if (module) module.exports = BigInt;
