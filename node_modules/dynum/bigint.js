var bi = (function() {
    function paddZeros(_number, digits) {
        var number = _number;
        while (number.length < digits) {
            number = '0' + number;
        }
        return number;
    }
    
    /**
     * Used for manipulating an array of bits.
     */
    function BitBuffer(anArray) {
        if (!anArray) {
            this.buffer = new Uint16Array(BitBuffer.baseLength);
            this.bits = 0;
        } else {
            this.buffer = anArray;
            this.bits = 0;
            
            // calculate how many bits we were given
            for (var i = this.buffer.length - 1; i >= 0; i--) {
                if (this.buffer[i] != 0) { 
                    for (var bitIndex = 15; bitIndex >= 0; bitIndex--) {
                        var mask = 1 << bitIndex;
                        if ((this.buffer[i] & mask) != 0) {
                            this.bits = (i * 16) + bitIndex + 1;
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }
    
    BitBuffer.baseLength = 4;

    BitBuffer.prototype.append = function(bitVal) {
        if (this.bits == this.buffer.length * 16) {
            var newBuff = new Uint16Array(this.buffer.length + BitBuffer.baseLength);
            for (var i = 0; i < this.buffer.length; i++) {
                newBuff[i] = this.buffer[i];
            }
            for (var j = this.buffer.length + 1; j < newBuff.length; j++) {
                newBuff[j] = 0;
            }
            newBuff[this.buffer.length] = bitVal ? 1 : 0;
            this.buffer = newBuff;
        } else if (bitVal) {
            var bitIndex = this.bits % 16;
            var cellIndex = (this.bits - bitIndex) / 16;
            var cellVal = this.buffer[cellIndex];
            
            cellVal |= (1 << bitIndex);
        
            this.buffer[cellIndex] = cellVal;
        }
        this.bits++;
    }

    BitBuffer.prototype.get = function(anIndex) {
        if (anIndex >= this.bits) throw new Error('Access out of bounds');
        var cellIndex = Math.floor(anIndex / 16);
        var bitIndex = anIndex % 16;
        
        return (this.buffer[cellIndex] & (1 << bitIndex)) != 0;
    }

    BitBuffer.prototype.set = function(anIndex, flag) {
        if (anIndex >= this.bits) throw new Error('Access out of bounds');
        var cellIndex = Math.floor(anIndex / 16);
        var bitIndex = anIndex % 16;
        if (flag) {
            this.buffer[cellIndex] |= (1 << bitIndex);
        } else {
            this.buffer[cellIndex] &= 0xffff ^ (1 << bitIndex);
        }
    }

    BitBuffer.prototype.trimmed = function() {
        // TODO: optimize this to be cell for cell
        var lastOne = -1;
        for (var i = this.bits - 1; i >= 0; i--) {
            if (this.get(i)) {
                lastOne = i;
                break;
            }
        }
        var result = new BitBuffer();
        for (var i = 0; i <= lastOne; i++) {
            result.append(this.get(i));
        }
        return result;
    }
    
    BitBuffer.prototype.copy = function() {
        // TODO: optimize this to be cell for cell
        var buffer = new BitBuffer();
        for (var i = 0; i < this.bits; i++) {
            buffer.append(this.get(i));
        }
        return buffer;
    }

    BitBuffer.prototype.getCell = function(cell) {
        if (cell >= this.buffer.length) return 0;
        if (cell < 0) return 0;
        return this.buffer[cell];
    }
    
    BitBuffer.prototype.cellCount = function() {
        return Math.ceil(this.bits / 16);
    }

    function BigInt(buffer, sign) {
        this.buffer = buffer;
        this.sign = sign;
    }
    
    BigInt.multiplyWords = function(zeroOffset, word, wordList, wordCount) {
        var result = new Uint16Array(wordCount + 1 + zeroOffset);
        var carry = 0;
        for (var i = 0; i < wordCount; i++) {
            var sum = wordList[i] * word + carry;
            var modulus = sum % 0x10000;
            result[i + zeroOffset] = modulus;
            carry = Math.round((sum - modulus) / 0x10000);
        }
        result[wordCount + zeroOffset] = carry;
        if (!carry) {
            return result.subarray(0, wordCount + zeroOffset);
        }
        return result;
    }
    
    BigInt.addWords = function(words1, words2) {
        var wordCount = Math.max(words1.length, words2.length) + 1;
        var result = new Uint16Array(wordCount);
        var carry = 0;
        for (var i = 0; i < wordCount; i++) {
            var word1 = i < words1.length ? words1[i] : 0;
            var word2 = i < words2.length ? words2[i] : 0;
            var sum = word1 + word2 + carry;
            var modulus = sum % 0x10000;
            result[i] = modulus;
            carry = Math.round((sum - modulus) / 0x10000);
        }
        if (!result[wordCount - 1]) {
            return result.subarray(0, wordCount - 1);
        }
        return result;
    }

    BigInt.prototype.bitCount = function() {
        return this.buffer.bits;
    }

    BigInt.prototype.neg = function() {
        return new BigInt(this.buffer, !this.sign);
    }

    BigInt.prototype.getBit = function(i) {
        if (i >= this.bitCount()) return false;
        return this.buffer.get(i);
    }
    
    BigInt.prototype.setBit = function(bit, flag) {
        var newBuff = this.buffer.copy();
        if (bit >= newBuff.bits) {
            while (bit > newBuff.bits) {
                newBuff.append(false);
            }
            newBuff.append(flag);
        } else {
            newBuff.set(bit, flag);
        }
        return new BigInt(newBuff.trimmed(), this.sign);
    }

    BigInt.prototype.isGreater = function(a) {
        if (this.isEqual(a)) return false;
        if (a.sign != this.sign) {
            if (this.sign) return true;
            return false;
        }
        if (!a.sign) {
            return a.neg().isGreater(this.neg());
        }
        if (this.bitCount() > a.bitCount()) return true;
        if (this.bitCount() < a.bitCount()) return false;
        // compare from greatest to least
        for (var i = this.buffer.cellCount() - 1; i >= 0; i--) {
            var thisVal = this.buffer.getCell(i);
            var aVal = a.buffer.getCell(i);
            if (thisVal > aVal) return true;
            if (thisVal < aVal) return false;
        }
        return false;
    }

    BigInt.prototype.isEqual = function(a) {
        if (this.bitCount() != a.bitCount()) return false;
        if (this.bitCount() == 0) return true;
        if (this.sign != a.sign) return false;
        for (var i = 0; i < this.buffer.cellCount(); i++) {
            if (this.buffer.getCell(i) != a.buffer.getCell(i)) {
                return false;
            }
        }
        return true;
    }

    BigInt.prototype.shiftLeft = function(num) {
        if (this.bitCount() == 0) return this;
        // append num zeros
        var buffer = new BitBuffer();
        for (var i = 0; i < num; i++) {
            buffer.append(false);
        }
        for (var i = 0; i < this.bitCount(); i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer, this.sign);
    }
    
    BigInt.prototype.shiftRight = function(num) {
        var buffer = new BitBuffer();
        for (var i = num; i < this.bitCount(); i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer, this.sign);
    }
    
    BigInt.prototype.lsb = function(bitCount) {
        var buffer = new BitBuffer();
        for (var i = 0; i < bitCount; i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer.trimmed(), this.sign);
    }

    BigInt.prototype.mul = function(obj) {
        var result = new Uint16Array(0);
        var objCells = obj.buffer.buffer;
        var objCellCount = obj.buffer.cellCount();
        for (var j = 0; j < this.buffer.cellCount(); j++) {
            var cell = this.buffer.getCell(j);
            var product = BigInt.multiplyWords(j, cell, objCells, objCellCount);
            result = BigInt.addWords(product, result);
        }
        
        return new BigInt(new BitBuffer(result), this.sign == obj.sign);
    }

    BigInt.prototype.div = function(obj) {
        return this.divMod(obj).div;
    }
    
    BigInt.prototype.divMod = function(obj) {
        // for odd sign cases
        if (!this.sign || !obj.sign) {
            var thisNew = this.sign ? this : this.neg();
            var objNew = obj.sign ? obj : obj.neg();
            var result = thisNew.divMod(objNew);
            if (this.sign != obj.sign) {
                result.mod = result.mod.neg();
                result.div = result.div.neg();
            }
            return result;
        }
        if (obj.bitCount() == 0) throw new Error('Cannot divide by zero');
        if (this.bitCount() == 0) return {mod: BigInt.zero, div: BigInt.zero};
        
        // positive sign code
        if (obj.isGreater(this)) return {mod: this, div: BigInt.zero};
        
        // recursive method for finding the quotient
        var mostSig = this.buffer.getCell(this.buffer.cellCount() - 1);
        var divSig = obj.buffer.getCell(obj.buffer.cellCount() - 1);
        var cellCount = this.buffer.cellCount() - obj.buffer.cellCount() + 1;
        
        // calculate if even 1 in this cell is too much
        var isTooBig = false;
        for (var i = obj.buffer.cellCount() - 1; i >= 0; i--) {
            var objCell = obj.buffer.getCell(i);
            var thisCell = this.buffer.getCell(i + cellCount - 1);
            if (objCell < thisCell) break;
            if (objCell > thisCell) {
                isTooBig = true;
                break;
            }
        }
        
        // give our information based on carrying etc.
        var useIndex = cellCount - 1;
        if (isTooBig) {
            // we can't do a typical division :'(
            if (cellCount == 1) throw new Error('This is impossible');
            mostSig = (mostSig * 0x10000) + this.buffer.getCell(this.buffer.cellCount() - 2);
            useIndex = cellCount - 2;
        }
        
        // we can do a/b to get an upper bound, and a/(b + 1) to get a lower bound
        // for this current cell
        var quotientMax = Math.round((mostSig - (mostSig % divSig)) / divSig);
        divSig++;
        var quotientMin = Math.round((mostSig - (mostSig % divSig)) / divSig);
        
        // edge case where both starting cells are 0xffff
        if (quotientMax > 0xffff) quotientMax = quotientMin;
        
        // calculate quotientMax*65536^useIndex*obj
        var productBuffer = BigInt.multiplyWords(useIndex, quotientMax,
                                                 obj.buffer.buffer,
                                                 obj.buffer.cellCount());
        var shave = new BigInt(new BitBuffer(productBuffer), true);
        
        var array = new Uint16Array(useIndex + 1);
        // TODO: try binary search here to find perfect shave
        if (shave.isGreater(this)) {
            // same calculation, but with quotientMin
            productBuffer = BigInt.multiplyWords(useIndex, quotientMin,
                                                 obj.buffer.buffer,
                                                 obj.buffer.cellCount());
            shave = new BigInt(new BitBuffer(productBuffer), true);
            array[useIndex] = quotientMin
        } else array[useIndex] = quotientMax;
        
        var remaining = this.sub(shave);
        var nextStep = remaining.divMod(obj);
        var result = new BigInt(new BitBuffer(array), true);
        return {div: result.add(nextStep.div), mod: nextStep.mod};
    }

    BigInt.prototype.add = function(obj) {
        // special cases for sign
        if (this.sign == obj.sign) {
            if (!this.sign) {
                // adding two negative numbers
                return this.neg().add(obj.neg()).neg();
            }
        } else {
            if (this.sign) {
                // adding a negative number
                return this.sub(obj.neg());
            } else {
                // adding to a negative number
                return obj.sub(this.neg());
            }
        }
    
        // primitive positive-positive addition!
        var digitCount = Math.max(this.bitCount(), obj.bitCount()) + 1;
        var wordArray = new Uint16Array(Math.ceil(digitCount / 16));
        var carry = 0;
        
        for (var i = 0; i < wordArray.length; i++) {
            var thisCell = this.buffer.getCell(i);
            var objCell = obj.buffer.getCell(i);
            var sum = carry + thisCell + objCell;
            wordArray[i] = sum % 0x10000;
            carry = Math.round((sum - wordArray[i]) / 0x10000);
        }
        return new BigInt(new BitBuffer(wordArray), true);
    }

    BigInt.prototype.sub = function(obj) {
        // special cases
        if (this.sign == obj.sign) {
            if (!this.sign) {
                // negative minus negative
                return obj.neg().sub(this.neg());
            }
        } else {
            if (this.sign) {
                // positive minus negative
                return this.add(obj.neg());
            } else {
                // negative minus positive
                return this.neg().add(obj).neg();
            }
        }
        
        // make sure this > obj, otherwise return negative
        // inverse result.
        if (obj.isGreater(this)) return obj.sub(this).neg();
    
        // compute the difference
        var wordCount = this.buffer.cellCount();
        var cells = new Uint16Array(wordCount);
        var carry = false;
        for (var i = 0; i < wordCount; i++) {
            var thisCell = this.buffer.getCell(i);
            var objCell = obj.buffer.getCell(i);
            
            // handle carrying
            if (carry) thisCell -= 1;
            if (thisCell < objCell) {
                thisCell += 0x10000;
                carry = true;
            } else carry = false;
            
            cells[i] = thisCell - objCell;
        }
        return new BigInt(new BitBuffer(cells), true);
    }

    BigInt.prototype.mod = function(value) {
        return this.divMod(value).mod;
    }

    BigInt.prototype.toInt = function() {
        var intVal = 0;
        var mul = 1;
        for (var i = 0; i < this.bitCount(); i++) {
            intVal += (this.getBit(i) ? mul : 0);
            mul *= 2;
        }
        return intVal;
    }

    BigInt.prototype.toString = function() {
        if (!this.sign) {
            return '-' + this.neg().toString();
        }
        var num = this;
        var digitCount = 8;
        var radix = BigInt.fromInt(Math.pow(10, digitCount));
        var string = '';
        while (num.bitCount() > 0) {
            var modDiv = num.divMod(radix);
            num = modDiv.div;
            
            var intStr = modDiv.mod.toInt().toString();
            if (num.bitCount() > 0) {
                intStr = paddZeros(intStr, digitCount);
            }
            string = intStr + string;
        }
        return string.length == 0 ? '0' : string;
    }
    
    BigInt.prototype.binaryString = function() {
        if (!this.sign) {
            return '-' + this.neg().binaryString();
        }
        var str = '';
        for (var i = 0; i < this.bitCount(); i++) {
            str = (this.getBit(i) ? '1' : '0') + str;
        }
        return '0b' + (str.length == 0 ? '0' : str);
    }

    BigInt.zero = new BigInt(new BitBuffer(), true);

    BigInt.fromInt = function(_value) {
        var sign = _value >= 0;
        var value = Math.floor(Math.abs(_value));
        var buffer = new BitBuffer();
        while (value > 0) {
            var flag = value % 2;
            buffer.append(flag == 1);
            value >>= 1;
        }
        return new BigInt(buffer, sign);
    }

    BigInt.fromString = function(string) {
        if (string[0] == '-') return BigInt.fromString(string.substring(1)).neg();
        
        var ten = BigInt.fromInt(10);
        var place = BigInt.fromInt(1);
    
        var digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        var result = BigInt.zero;
        for (var i = string.length - 1; i >= 0; i--) {
            var digit = string[i];
            var digitValue = digits.indexOf(digit);
            if (digitValue < 0) throw new Error('Invalid decimal string');
        
            // add 10^n * digit
            var digitNum = BigInt.fromInt(digitValue);
            result = result.add(place.mul(digitNum));
            place = place.mul(ten);
        }
    
        return result;
    }
    return BigInt;
})();

var BigInt = bi;
if (module) module.exports = BigInt;
