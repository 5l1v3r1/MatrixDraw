var bi = (function() {
    function paddZeros(_number, digits) {
        var number = _number;
        while (number.length < digits) {
            number = '0' + number;
        }
        return number;
    }
    
    /**
     * Used for manipulating an array of bits.
     */
    function BitBuffer(anArray) {
        if (!anArray) {
            this.buffer = new Uint16Array(BitBuffer.baseLength);
            this.bits = 0;
        } else {
            this.buffer = anArray;
            this.bits = 0;
            
            // calculate how many bits we were given
            for (var i = this.buffer.length - 1; i >= 0; i--) {
                if (this.buffer[i] != 0) { 
                    for (var bitIndex = 15; bitIndex >= 0; bitIndex--) {
                        var mask = 1 << bitIndex;
                        if ((this.buffer[i] & mask) != 0) {
                            this.bits = (i * 16) + bitIndex + 1;
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }
    
    BitBuffer.baseLength = 4;

    BitBuffer.prototype.append = function(bitVal) {
        if (this.bits == this.buffer.length * 16) {
            var newBuff = new Uint16Array(this.buffer.length + BitBuffer.baseLength);
            for (var i = 0; i < this.buffer.length; i++) {
                newBuff[i] = this.buffer[i];
            }
            for (var j = this.buffer.length + 1; j < newBuff.length; j++) {
                newBuff[j] = 0;
            }
            newBuff[this.buffer.length] = bitVal ? 1 : 0;
            this.buffer = newBuff;
        } else if (bitVal) {
            var bitIndex = this.bits % 16;
            var cellIndex = (this.bits - bitIndex) / 16;
            var cellVal = this.buffer[cellIndex];
            
            cellVal |= (1 << bitIndex);
        
            this.buffer[cellIndex] = cellVal;
        }
        this.bits++;
    }

    BitBuffer.prototype.get = function(bitIndex) {
        if (bitIndex >= this.bits) throw new Error('Access out of bounds');
        var cellIndex = Math.floor(bitIndex / 16);
        var bitIndex = bitIndex % 16;
        
        return (this.buffer[cellIndex] & (1 << bitIndex)) != 0;
    }

    BitBuffer.prototype.set = function(bitIndex, flag) {
        if (bitIndex >= this.bits) throw new Error('Access out of bounds');
        var cellIndex = Math.floor(bitIndex / 16);
        var bitIndex = bitIndex % 16;
        if (flag) {
            this.buffer[cellIndex] |= (1 << bitIndex);
        } else {
            this.buffer[cellIndex] &= 0xffff ^ (1 << bitIndex);
        }
    }

    BitBuffer.prototype.trimmed = function() {
        // TODO: optimize this to be cell for cell
        var lastOne = -1;
        for (var i = this.bits - 1; i >= 0; i--) {
            if (this.get(i)) {
                lastOne = i;
                break;
            }
        }
        var result = new BitBuffer();
        for (var i = 0; i <= lastOne; i++) {
            result.append(this.get(i));
        }
        return result;
    }
    
    BitBuffer.prototype.copy = function() {
        // TODO: optimize this to be cell for cell
        var buffer = new BitBuffer();
        for (var i = 0; i < this.bits; i++) {
            buffer.append(this.get(i));
        }
        return buffer;
    }

    BitBuffer.prototype.getCell = function(cell) {
        if (cell >= this.buffer.length) return 0;
        return this.buffer[cell];
    }
    
    BitBuffer.prototype.cellCount = function() {
        return Math.ceil(this.bits / 16);
    }

    function BigInt(buffer, sign) {
        this.buffer = buffer;
        this.sign = sign;
    }
    
    BigInt.multiplyWords = function(zeroOffset, word, wordList, wordCount) {
        var result = new Uint16Array(wordCount + 1 + zeroOffset);
        var carry = 0;
        for (var i = 0; i < wordCount; i++) {
            var sum = wordList[i] * word + carry;
            var modulus = sum % 0x10000;
            result[i + zeroOffset] = modulus;
            carry = Math.round((sum - modulus) / 0x10000);
        }
        result[wordCount + zeroOffset] = carry;
        if (!carry) {
            return result.subarray(0, wordCount + zeroOffset);
        }
        return result;
    }
    
    BigInt.addWords = function(words1, words2) {
        var wordCount = Math.max(words1.length, words2.length) + 1;
        var result = new Uint16Array(wordCount);
        var carry = 0;
        for (var i = 0; i < wordCount; i++) {
            var word1 = i < words1.length ? words1[i] : 0;
            var word2 = i < words2.length ? words2[i] : 0;
            var sum = word1 + word2 + carry;
            var modulus = sum % 0x10000;
            result[i] = modulus;
            carry = Math.round((sum - modulus) / 0x10000);
        }
        return result;
    }

    BigInt.prototype.bitCount = function() {
        return this.buffer.bits;
    }

    BigInt.prototype.neg = function() {
        return new BigInt(this.buffer, !this.sign);
    }

    BigInt.prototype.getBit = function(i) {
        if (i >= this.bitCount()) return false;
        return this.buffer.get(i);
    }
    
    BigInt.prototype.setBit = function(bit, flag) {
        var newBuff = this.buffer.copy();
        if (bit >= newBuff.bits) {
            while (bit > newBuff.bits) {
                newBuff.append(false);
            }
            newBuff.append(flag);
        } else {
            newBuff.set(bit, flag);
        }
        return new BigInt(newBuff.trimmed(), this.sign);
    }

    BigInt.prototype.isGreater = function(a) {
        if (this.isEqual(a)) return false;
        if (a.sign != this.sign) {
            if (this.sign) return true;
            return false;
        }
        if (!a.sign) {
            return a.neg().isGreater(this.neg());
        }
        if (this.bitCount() > a.bitCount()) return true;
        if (this.bitCount() < a.bitCount()) return false;
        // compare from greatest to least
        for (var i = this.bitCount() - 1; i >= 0; i--) {
            var thisVal = this.buffer.get(i);
            var aVal = a.buffer.get(i);
            if (thisVal && !aVal) return true;
            if (!thisVal && aVal) return false;
        }
        return false;
    }

    BigInt.prototype.isEqual = function(a) {
        if (this.bitCount() != a.bitCount()) return false;
        if (this.bitCount() == 0) return true;
        if (this.sign != a.sign) return false;
        for (var i = 0; i < this.bitCount(); i++) {
            if (this.buffer.get(i) != a.buffer.get(i)) {
                return false;
            }
        }
        return true;
    }

    BigInt.prototype.shiftLeft = function(num) {
        if (this.bitCount() == 0) return this;
        // append num zeros
        var buffer = new BitBuffer();
        for (var i = 0; i < num; i++) {
            buffer.append(false);
        }
        for (var i = 0; i < this.bitCount(); i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer, this.sign);
    }
    
    BigInt.prototype.shiftRight = function(num) {
        var buffer = new BitBuffer();
        for (var i = num; i < this.bitCount(); i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer, this.sign);
    }
    
    BigInt.prototype.lsb = function(bitCount) {
        var buffer = new BitBuffer();
        for (var i = 0; i < bitCount; i++) {
            buffer.append(this.getBit(i));
        }
        return new BigInt(buffer.trimmed(), this.sign);
    }

    BigInt.prototype.mul = function(obj) {
        var result = new Uint16Array(0);
        var objCells = obj.buffer.buffer;
        var objCellCount = obj.buffer.cellCount();
        for (var j = 0; j < this.buffer.cellCount(); j++) {
            var cell = this.buffer.getCell(j);
            var product = BigInt.multiplyWords(j, cell, objCells, objCellCount);
            result = BigInt.addWords(product, result);
        }
        
        return new BigInt(new BitBuffer(result), this.sign == obj.sign);
    }

    BigInt.prototype.div = function(obj) {
        if (!this.sign) return this.neg().div(obj).neg();
        if (!obj.sign) return this.div(obj.neg()).neg();
        if (obj.isGreater(this)) return BigInt.zero;
        if (obj.bitCount() == 0) throw new Error('Divide by zero exception');
    
        var result = BigInt.zero;
        var product = BigInt.zero;
        // binary search
        for (var digit = this.bitCount() - 1; digit >= 0; digit--) {
            var shiftedObj = obj.shiftLeft(digit);
            var testProduct = product.add(shiftedObj);
            if (!testProduct.isGreater(this)) {
                result = result.setBit(digit, true);
                product = testProduct;
            }
        }
        
        return result;
    }
    
    BigInt.prototype.divMod = function(obj) {
        if (!this.sign) return this.neg().divMod(obj).neg();
        if (!obj.sign) return this.divMod(obj.neg()).neg();
        if (obj.isGreater(this)) return {mod: this, div: BigInt.zero};
    
        var result = BigInt.zero;
        var product = BigInt.zero;
        // binary search
        for (var digit = this.bitCount() - 1; digit >= 0; digit--) {
            var shiftedObj = obj.shiftLeft(digit);
            var testProduct = product.add(shiftedObj);
            if (!testProduct.isGreater(this)) {
                result = result.setBit(digit, true);
                product = testProduct;
            }
        }
        var modulus = this.sub(product);
        return {div: result, mod: modulus};
    }

    BigInt.prototype.add = function(obj) {
        // special cases for sign
        if (this.sign == obj.sign) {
            if (!this.sign) {
                // adding two negative numbers
                return this.neg().add(obj.neg()).neg();
            }
        } else {
            if (this.sign) {
                // adding a negative number
                return this.sub(obj.neg());
            } else {
                // adding to a negative number
                return obj.sub(this.neg());
            }
        }
    
        // primitive positive-positive addition!
        var digitCount = Math.max(this.bitCount(), obj.bitCount()) + 1;
        var wordArray = new Uint16Array(Math.ceil(digitCount / 16));
        var carry = 0;
        
        for (var i = 0; i < wordArray.length; i++) {
            var thisCell = this.buffer.getCell(i);
            var objCell = obj.buffer.getCell(i);
            var sum = carry + thisCell + objCell;
            wordArray[i] = sum % 0x10000;
            carry = Math.round((sum - wordArray[i]) / 0x10000);
        }
        return new BigInt(new BitBuffer(wordArray), true);
    }

    BigInt.prototype.sub = function(obj) {
        // special cases
        if (this.sign == obj.sign) {
            if (!this.sign) {
                // negative minus negative
                return obj.neg().sub(this.neg());
            }
        } else {
            if (this.sign) {
                // positive minus negative
                return this.add(obj.neg());
            } else {
                // negative minus positive
                return this.neg().add(obj).neg();
            }
        }
        
        // make sure this > obj, otherwise return negative
        // inverse result.
        if (obj.isGreater(this)) return obj.sub(this).neg();
    
        // compute the difference
        var wordCount = this.buffer.cellCount();
        var cells = new Uint16Array(wordCount);
        var carry = false;
        for (var i = 0; i < wordCount; i++) {
            var thisCell = this.buffer.getCell(i);
            var objCell = obj.buffer.getCell(i);
            
            // handle carrying
            if (carry) thisCell -= 1;
            if (thisCell < objCell) {
                thisCell += 0x10000;
                carry = true;
            } else carry = false;
            
            cells[i] = thisCell - objCell;
        }
        return new BigInt(new BitBuffer(cells), true);
    }

    BigInt.prototype.mod = function(value) {
        return this.divMod(value).mod;
    }

    BigInt.prototype.toInt = function() {
        var intVal = 0;
        var mul = 1;
        for (var i = 0; i < this.bitCount(); i++) {
            intVal += (this.getBit(i) ? mul : 0);
            mul *= 2;
        }
        return intVal;
    }

    BigInt.prototype.toString = function() {
        if (!this.sign) {
            return '-' + this.neg().toString();
        }
        var num = this;
        var digitCount = 8;
        var radix = BigInt.fromInt(Math.pow(10, digitCount));
        var string = '';
        while (num.bitCount() > 0) {
            var modDiv = num.divMod(radix);
            num = modDiv.div;
            
            var intStr = modDiv.mod.toInt().toString();
            if (num.bitCount() > 0) {
                intStr = paddZeros(intStr, digitCount);
            }
            string = intStr + string;
        }
        return string.length == 0 ? '0' : string;
    }
    
    BigInt.prototype.binaryString = function() {
        var str = '';
        for (var i = 0; i < this.bitCount(); i++) {
            str = (this.getBit(i) ? '1' : '0') + str;
        }
        return '0b' + (str.length == 0 ? '0' : str);
    }

    BigInt.zero = new BigInt(new BitBuffer(), true);

    BigInt.fromInt = function(_value) {
        var sign = _value >= 0;
        var value = Math.floor(Math.abs(_value));
        var buffer = new BitBuffer();
        while (value > 0) {
            var flag = value % 2;
            buffer.append(flag == 1);
            value >>= 1;
        }
        return new BigInt(buffer, sign);
    }

    BigInt.fromString = function(string) {
        if (string[0] == '-') return BigInt.fromString(string.substring(1)).neg();
        
        var ten = BigInt.fromInt(10);
        var place = BigInt.fromInt(1);
    
        var digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        var result = BigInt.zero;
        for (var i = string.length - 1; i >= 0; i--) {
            var digit = string[i];
            var digitValue = digits.indexOf(digit);
            if (digitValue < 0) throw new Error('Invalid decimal string');
        
            // add 10^n * digit
            var digitNum = BigInt.fromInt(digitValue);
            result = result.add(place.mul(digitNum));
            place = place.mul(ten);
        }
    
        return result;
    }
    return BigInt;
})();

var BigInt = bi;
if (module) module.exports = BigInt;
