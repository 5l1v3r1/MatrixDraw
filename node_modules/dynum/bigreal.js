if (typeof BigInt == 'undefined') {
    BigInt = require('./bigint.js');
}

var br = (function() {
    
    function BigReal(number, power) {
        this.number = number;
        this.exp = power;
    }
    
    BigReal.precision = 64;
    
    BigReal.withPrecision = function(prec, fn) {
        var backup = BigReal.precision;
        BigReal.precision = prec;
        try {
            fn();
        } catch (e) {
            BigReal.precision = backup;
            throw e;
        }
        BigReal.precision = backup;
    }
    
    BigReal.fromFloat = function(theFloat) {
        var power = 29 - Math.round(Math.log(theFloat) / Math.log(2));
        var decNumber = Math.round(Math.pow(2, power) * theFloat);
        var number = BigInt.fromInt(Math.round(decNumber));
        return new BigReal(number, -power).roundToPrecision();
    }
    
    BigReal.zero = new BigReal(BigInt.zero, 0);
    
    BigReal.log2Ceil = function() {
        return this.bitCount() + this.exp;
    }
    
    BigReal.prototype.toFloat = function() {
        var tempNum = this.roundToPrecision(31);
        var intPart = tempNum.number.toInt();
        return Math.pow(2, tempNum.exp) * intPart;
    }
    
    BigReal.prototype.shiftLeft = function(pow) {
        return new BigReal(this.number, this.exp + pow);
    }
    
    BigReal.prototype.shiftRight = function(pow) {
        return this.shiftLeft(-pow);
    }
    
    BigReal.prototype.roundToPrecision = function(_prec) {
        var prec = _prec || BigReal.precision;
        var number = this.number;
        var exp = this.exp;
        
        if (number.bitCount() > prec) {
            var shaveBits = number.bitCount() - prec;
            var carry = number.getBit(shaveBits - 1);
            exp += shaveBits;
            number = number.shiftRight(shaveBits);
                        
            // add carry flag; on rare case that this increases
            // the number of digits again, we should shave off all
            // of the prior digits.
            if (carry) number = number.add(BigInt.fromInt(1));
            if (number.bitCount() > prec) {
                number = number.shiftRight(prec);
                exp += prec;
            }
        }
        return new BigReal(number, exp);
    }
    
    /**
     * Given a*2^n, b*2^m; returns two integers,
     * both when multiplied by 2^x are equal to the
     * input floating points.
     * @return [thisInt, numInt]
     */
    BigReal.prototype.levelIntegers = function(num) {
        if (num.exp < this.exp) {
            var res = num.levelIntegers(this);
            return [res[1], res[0]];
        }
        var shift = num.exp - this.exp;
        var newNumber = num.number.shiftLeft(shift);
        var newExp = num.exp - shift;
        return [this.number, newNumber];
    }
    
    BigReal.prototype.isEqual = function(num) {
        var ints = this.levelIntegers(num);
        return ints[0].isEqual(ints[1]);
    }
    
    BigReal.prototype.isGreater = function(num) {
        // check equality first
        if (this.isEqual(num)) return false;
        
        // compare obvious sign differences
        if (this.number.sign && !num.number.sign) return true;
        if (!this.number.sign && num.number.sign) return false;
        if (!this.number.sign && !num.number.sign) {
            return num.neg().isGreater(this.neg());
        }
        
        // level out the playing field
        var ints = this.levelIntegers(num);
        return ints[0].isGreater(ints[1]);
    }
    
    BigReal.prototype.neg = function() {
        return new BigReal(this.number.neg(), this.exp);
    }
    
    BigReal.prototype.abs = function() {
        if (!this.number.sign) return this.neg();
        return this;
    }
    
    BigReal.prototype.add = function(num) {
        // TODO: check here for lack of overlap
        
        // level out the exponents (i.e. a*2^n + b*2^n)
        if (num.exp > this.exp) {
            var shift = num.exp - this.exp;
            var newNum = num.number.shiftLeft(shift);
            var level = new BigReal(newNum, this.exp);
            return this.add(level);
        } else if (num.exp < this.exp) {
            var shift = this.exp - num.exp;
            var newNum = this.number.shiftLeft(shift);
            var level = new BigReal(newNum, num.exp);
            return level.add(num);
        }
        
        // compute our level value
        var unbounded = this.number.add(num.number);
        return new BigReal(unbounded, this.exp).roundToPrecision();
    }
    
    BigReal.prototype.mul = function(num) {
        var newNum = this.number.mul(num.number);
        var newExp = this.exp + num.exp;
        return new BigReal(newNum, newExp).roundToPrecision();
    }
    
    BigReal.prototype.sub = function(num) {
        return this.add(num.neg());
    }
    
    BigReal.prototype.div = function(num) {
        // TODO: figure this out
        var shiftCount = BigReal.precision + num.number.bitCount() - this.number.bitCount();
        var thisNumber = this.number.shiftLeft(Math.max(0, shiftCount));
        var number = thisNumber.div(num.number);
        var exp = this.exp - shiftCount - num.exp;
        return new BigReal(number, exp).roundToPrecision();
    }
    
    BigReal.prototype.sqrt = function() {
        // use the Babylonian method to compute an accurate root
        if (this.number.bitCount() == 0) return BigReal.zero;
        var guess = this;
        var difference = null;
        var epsilon = BigReal.zero.shiftRight(BigReal.precision / 2);
        var two = BigReal.fromFloat(2);
        while (true) {
            // get the current error
            var guessSquare = guess.mul(guess);
            var tmpDifference = guessSquare.sub(this).abs();
            if (difference && tmpDifference.isEqual(difference)) break;
            difference = tmpDifference;
            
            // generate the next guess
            guess = guess.add(this.div(guess)).div(two);
        }
        return guess;
    }
    
    BigReal.prototype.toString = function() {
        return this.number + '*2^' + this.exp;
    }
    
    return BigReal;
})();

var BigReal = br;
if (module) {
    module.exports = BigReal;
}