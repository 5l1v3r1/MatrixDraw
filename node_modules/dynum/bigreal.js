if (typeof BigInt == 'undefined') {
    BigInt = require('./bigint.js');
}

var br = (function() {
    
    function BigReal(number, power) {
        this.number = number;
        this.exp = power;
    }
    
    BigReal.precision = 64;
    
    BigReal.withPrecision = function(prec, fn) {
        var backup = BigReal.precision;
        BigReal.precision = prec;
        try {
            fn();
        } catch (e) {
            BigReal.precision = backup;
            throw e;
        }
        BigReal.precision = backup;
    }
    
    BigReal.fromFloat = function(theFloat) {
        if (theFloat == 0) return BigReal.zero;
        
        var power = 29 - Math.round(Math.log(theFloat) / Math.log(2));
        var decNumber = Math.round(Math.pow(2, power) * theFloat);
        var number = BigInt.fromInt(Math.round(decNumber));
        return new BigReal(number, -power).roundToPrecision();
    }
    
    BigReal.fromString = function(string) {
        var parts = string.split('.');
        if (parts.length == 1) {
            return new BigReal(BigInt.fromString(string), 0);
        } else if (parts.length != 2) {
            throw new Error('Invalid input string');
        }
        
        // start with an int part
        var number = new BigReal(BigInt.fromString(parts[0]), 0);
        
        // add fractional part
        var digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        var ten = BigReal.fromFloat(10);
        var multiplier = BigReal.fromFloat(1);
        var maxDigs = BigReal.precision / (Math.log(10)/Math.log(2));
        for (var i = 0; i < Math.min(maxDigs, parts[1].length); i++) {
            var digit = digits.indexOf(parts[1][i]);
            if (digit < 0) throw new Error('Invalid digit: ' + parts[1][i]);
            multiplier = multiplier.div(ten);
            var digitVal = BigReal.fromFloat(digit);
            number = number.add(multiplier.mul(digitVal));
        }
        return number;
    }
    
    BigReal.zero = new BigReal(BigInt.zero, 0);
    
    BigReal.log2Ceil = function() {
        return this.bitCount() + this.exp;
    }
    
    BigReal.prototype.toFloat = function() {
        var tempNum = this.roundToPrecision(31);
        var intPart = tempNum.number.toInt();
        return Math.pow(2, tempNum.exp) * intPart;
    }
    
    BigReal.prototype.shiftLeft = function(pow) {
        return new BigReal(this.number, this.exp + pow);
    }
    
    BigReal.prototype.shiftRight = function(pow) {
        return this.shiftLeft(-pow);
    }
    
    BigReal.prototype.roundToPrecision = function(_prec) {
        var prec = _prec || BigReal.precision;
        var number = this.number;
        var exp = this.exp;
        
        if (number.bitCount() > prec) {
            var shaveBits = number.bitCount() - prec;
            var carry = number.getBit(shaveBits - 1);
            exp += shaveBits;
            number = number.shiftRight(shaveBits);
                        
            // add carry flag; on rare case that this increases
            // the number of digits again, we should shave off all
            // of the prior digits.
            if (carry) number = number.add(BigInt.fromInt(1));
            if (number.bitCount() > prec) {
                number = number.shiftRight(prec);
                exp += prec;
            }
        }
        return new BigReal(number, exp);
    }
    
    /**
     * Given a*2^n, b*2^m; returns two integers,
     * both when multiplied by 2^x are equal to the
     * input floating points.
     * @return [thisInt, numInt]
     */
    BigReal.prototype.levelIntegers = function(num) {
        if (num.exp < this.exp) {
            var res = num.levelIntegers(this);
            return [res[1], res[0]];
        }
        var shift = num.exp - this.exp;
        var newNumber = num.number.shiftLeft(shift);
        var newExp = num.exp - shift;
        return [this.number, newNumber];
    }
    
    BigReal.prototype.isEqual = function(num) {
        var ints = this.levelIntegers(num);
        return ints[0].isEqual(ints[1]);
    }
    
    BigReal.prototype.isGreater = function(num) {
        // check equality first
        if (this.isEqual(num)) return false;
        
        // compare obvious sign differences
        if (this.number.sign && !num.number.sign) return true;
        if (!this.number.sign && num.number.sign) return false;
        if (!this.number.sign && !num.number.sign) {
            return num.neg().isGreater(this.neg());
        }
        
        // level out the playing field
        var ints = this.levelIntegers(num);
        return ints[0].isGreater(ints[1]);
    }
    
    BigReal.prototype.neg = function() {
        return new BigReal(this.number.neg(), this.exp);
    }
    
    BigReal.prototype.abs = function() {
        if (!this.number.sign) return this.neg();
        return this;
    }
    
    BigReal.prototype.wholeFrac = function() {
        // two edge cases
        if (this.exp >= 0) { 
            return {whole: this, frac: BigReal.zero};
        }
        if (-this.exp >= this.number.bitCount()) {
            return {whole: BigReal.zero, frac: this};
        }
        // split case
        var negBits = -this.exp;
        var whole = new BigReal(this.number.shiftRight(negBits), 0);
        var frac = new BigReal(this.number.lsb(negBits), this.exp);
        return {whole: whole, frac: frac};
    }
    
    BigReal.prototype.add = function(num) {
        // TODO: check here for lack of overlap
        
        // level out the exponents (i.e. a*2^n + b*2^n)
        if (num.exp > this.exp) {
            var shift = num.exp - this.exp;
            var newNum = num.number.shiftLeft(shift);
            var level = new BigReal(newNum, this.exp);
            return this.add(level);
        } else if (num.exp < this.exp) {
            var shift = this.exp - num.exp;
            var newNum = this.number.shiftLeft(shift);
            var level = new BigReal(newNum, num.exp);
            return level.add(num);
        }
        
        // compute our level value
        var unbounded = this.number.add(num.number);
        return new BigReal(unbounded, this.exp).roundToPrecision();
    }
    
    BigReal.prototype.mul = function(num) {
        var newNum = this.number.mul(num.number);
        var newExp = this.exp + num.exp;
        var result = new BigReal(newNum, newExp).roundToPrecision();
        return result;
    }
    
    BigReal.prototype.sub = function(num) {
        return this.add(num.neg());
    }
    
    BigReal.prototype.div = function(num) {
        // TODO: figure this out
        var shiftCount = BigReal.precision + num.number.bitCount() - this.number.bitCount();
        var thisNumber = this.number.shiftLeft(Math.max(0, shiftCount));
        var number = thisNumber.div(num.number);
        var exp = this.exp - shiftCount - num.exp;
        return new BigReal(number, exp).roundToPrecision();
    }
    
    BigReal.prototype.sqrt = function() {
        // use the Babylonian method to compute an accurate root
        if (this.number.bitCount() == 0) return BigReal.zero;
        var guess = this;
        var difference = null;
        var epsilon = BigReal.zero.shiftRight(BigReal.precision / 2);
        var two = BigReal.fromFloat(2);
        while (true) {
            // get the current error
            var guessSquare = guess.mul(guess);
            var tmpDifference = guessSquare.sub(this).abs();
            if (difference && tmpDifference.isEqual(difference)) break;
            difference = tmpDifference;
            
            // generate the next guess
            guess = guess.add(this.div(guess)).div(two);
        }
        return guess;
    }
    
    BigReal.prototype.round = function() {
        var wf = this.wholeFrac();
        var oneHalf = BigReal.fromFloat(0.5);
        if (wf.frac.isGreater(oneHalf) || wf.frac.isEqual(oneHalf)) {
            return wf.whole.add(BigReal.fromFloat(1));
        }
        return wf.whole;
    }
    
    BigReal.prototype.toString = function() {
        var wf = this.wholeFrac();
        var result = null;
        BigReal.withPrecision(this.number.bitCount(), function() {
            var whole = wf.whole;
            var frac = wf.frac;
        
            // if we are equivalent to an integer, use that
            if (frac.isEqual(BigReal.zero)) {
                result = whole.number.toString();
                return;
            }
        
            // generate a floating point string
            var maxDigits = Math.ceil(frac.number.bitCount() / Math.log(10));
            var afterStr = '';
            var ten = BigReal.fromFloat(10);
            for (var i = 0; i < maxDigits; i++) {
                var parts = frac.mul(ten).wholeFrac();
                frac = parts.frac;
                afterStr += parts.whole.number.toString();
                if (frac.isEqual(BigReal.zero)) break;
            }
        
            result = whole.number.toString() + '.' + afterStr;
        });
        return result;
    }
    
    return BigReal;
})();

var BigReal = br;
if (module) {
    module.exports = BigReal;
}