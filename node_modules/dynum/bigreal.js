if (typeof BigInt == 'undefined') {
    BigInt = require('./bigint.js');
}

var br = (function() {
    
    function BigReal(number, power) {
        this.number = number;
        this.exp = power;
    }
    
    BigReal.precision = 64;
    
    BigReal.withPrecision = function(prec, fn) {
        var backup = BigReal.precision;
        BigReal.precision = prec;
        try {
            fn();
        } catch (e) {
            BigReal.precision = backup;
            throw e;
        }
        BigReal.precision = backup;
    }
    
    BigReal.fromFloat = function(theFloat) {
        if (theFloat == 0) return BigReal.zero;
        
        var power = 29 - Math.round(Math.log(theFloat) / Math.log(2));
        var decNumber = Math.round(Math.pow(2, power) * theFloat);
        var number = BigInt.fromInt(Math.round(decNumber));
        return new BigReal(number, -power).roundToPrecision();
    }
    
    BigReal.fromString = function(string) {
        var parts = string.split('.');
        if (parts.length == 1) {
            return new BigReal(BigInt.fromString(string), 0);
        } else if (parts.length != 2) {
            throw new Error('Invalid input string');
        }
        
        // start with an int part
        var number = new BigReal(BigInt.fromString(parts[0]), 0);
        
        // add fractional part
        var digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        var ten = BigReal.fromFloat(10);
        var multiplier = BigReal.fromFloat(1);
        var maxDigs = 1 + BigReal.precision / (Math.log(10)/Math.log(2)) - number.log2Ceil();
        for (var i = 0; i < Math.min(maxDigs, parts[1].length); i++) {
            var digit = digits.indexOf(parts[1][i]);
            if (digit < 0) throw new Error('Invalid digit: ' + parts[1][i]);
            multiplier = multiplier.div(ten);
            var digitVal = BigReal.fromFloat(digit);
            number = number.add(multiplier.mul(digitVal));
        }
        return number;
    }
    
    BigReal.zero = new BigReal(BigInt.zero, 0);
    
    BigReal.prototype.log2Ceil = function() {
        return this.number.bitCount() + this.exp;
    }
    
    BigReal.prototype.toFloat = function() {
        var tempNum = this.roundToPrecision(31);
        var intPart = tempNum.number.toInt();
        return Math.pow(2, tempNum.exp) * intPart;
    }
    
    BigReal.prototype.shiftLeft = function(pow) {
        return new BigReal(this.number, this.exp + pow);
    }
    
    BigReal.prototype.shiftRight = function(pow) {
        return this.shiftLeft(-pow);
    }
    
    BigReal.prototype.roundToPrecision = function(_prec) {
        var prec = _prec || BigReal.precision;
        var number = this.number;
        var exp = this.exp;
        
        if (number.bitCount() > prec) {
            var shaveBits = number.bitCount() - prec;
            var carry = number.getBit(shaveBits - 1);
            exp += shaveBits;
            number = number.shiftRight(shaveBits);
                        
            // add carry flag; on rare case that this increases
            // the number of digits again, we should shave off all
            // of the prior digits.
            if (carry) number = number.add(BigInt.fromInt(1));
            if (number.bitCount() > prec) {
                number = number.shiftRight(prec);
                exp += prec;
            }
        }
        return new BigReal(number, exp);
    }
    
    /**
     * Given a*2^n, b*2^m; returns two integers,
     * both when multiplied by 2^x are equal to the
     * input floating points.
     * @return [thisInt, numInt]
     */
    BigReal.prototype.levelIntegers = function(num) {
        if (num.exp < this.exp) {
            var res = num.levelIntegers(this);
            return [res[1], res[0]];
        }
        var shift = num.exp - this.exp;
        var newNumber = num.number.shiftLeft(shift);
        var newExp = num.exp - shift;
        return [this.number, newNumber];
    }
    
    BigReal.prototype.isEqual = function(num) {
        var ints = this.levelIntegers(num);
        return ints[0].isEqual(ints[1]);
    }
    
    BigReal.prototype.isGreater = function(num) {
        // check equality first
        if (this.isEqual(num)) return false;
        
        // compare obvious sign differences
        if (this.number.sign && !num.number.sign) return true;
        if (!this.number.sign && num.number.sign) return false;
        if (!this.number.sign && !num.number.sign) {
            return num.neg().isGreater(this.neg());
        }
        
        // level out the playing field
        var ints = this.levelIntegers(num);
        return ints[0].isGreater(ints[1]);
    }
    
    BigReal.prototype.neg = function() {
        return new BigReal(this.number.neg(), this.exp);
    }
    
    BigReal.prototype.abs = function() {
        if (!this.number.sign) return this.neg();
        return this;
    }
    
    BigReal.prototype.wholeFrac = function() {
        // two edge cases
        if (this.exp >= 0) { 
            return {whole: this, frac: BigReal.zero};
        }
        if (-this.exp >= this.number.bitCount()) {
            return {whole: BigReal.zero, frac: this};
        }
        // split case
        var negBits = -this.exp;
        var whole = new BigReal(this.number.shiftRight(negBits), 0);
        var frac = new BigReal(this.number.lsb(negBits), this.exp);
        return {whole: whole, frac: frac};
    }
    
    BigReal.prototype.add = function(num) {
        // TODO: check here for lack of overlap
        
        // level out the exponents (i.e. a*2^n + b*2^n)
        if (num.exp > this.exp) {
            var shift = num.exp - this.exp;
            var newNum = num.number.shiftLeft(shift);
            var level = new BigReal(newNum, this.exp);
            return this.add(level);
        } else if (num.exp < this.exp) {
            var shift = this.exp - num.exp;
            var newNum = this.number.shiftLeft(shift);
            var level = new BigReal(newNum, num.exp);
            return level.add(num);
        }
        
        // compute our level value
        var unbounded = this.number.add(num.number);
        return new BigReal(unbounded, this.exp).roundToPrecision();
    }
    
    BigReal.prototype.mul = function(num) {
        var newNum = this.number.mul(num.number);
        var newExp = this.exp + num.exp;
        var result = new BigReal(newNum, newExp).roundToPrecision();
        return result;
    }
    
    BigReal.prototype.sub = function(num) {
        return this.add(num.neg());
    }
    
    BigReal.prototype.div = function(num) {
        var shiftCount = Math.max(0, BigReal.precision + num.number.bitCount() - this.number.bitCount());
        var thisNumber = this.number.shiftLeft(shiftCount);
        var number = thisNumber.div(num.number);
        var exp = this.exp - shiftCount - num.exp;
        return new BigReal(number, exp).roundToPrecision();
    }
    
    BigReal.prototype.sqrt = function() {
        // use the Babylonian method to compute an accurate root
        if (this.number.bitCount() == 0) return BigReal.zero;
        var guess = this;
        var difference = null;
        var epsilon = BigReal.zero.shiftRight(BigReal.precision / 2);
        var two = BigReal.fromFloat(2);
        while (!difference || difference.isGreater(epsilon)) {
            // get the current error
            var guessSquare = guess.mul(guess);
            var tmpDifference = guessSquare.sub(this).abs();
            if (difference && tmpDifference.isEqual(difference)) break;
            difference = tmpDifference;
            
            // generate the next guess
            guess = guess.add(this.div(guess)).div(two);
        }
        return guess;
    }
    
    BigReal.prototype.round = function() {
        var wf = this.wholeFrac();
        var oneHalf = BigReal.fromFloat(0.5);
        if (wf.frac.isGreater(oneHalf) || wf.frac.isEqual(oneHalf)) {
            return wf.whole.add(BigReal.fromFloat(1));
        }
        return wf.whole;
    }
    
    BigReal.prototype.toString = function() {
        if (!this.number.sign) {
            return '-' + this.neg().toString();
        }
        var wf = this.wholeFrac();
        var result = null;
        BigReal.withPrecision(this.number.bitCount(), function() {
            var whole = wf.whole;
            var frac = wf.frac;
        
            // if we are equivalent to an integer, use that
            if (frac.isEqual(BigReal.zero)) {
                result = whole.number.toString();
                return;
            }
        
            // generate a floating point string
            var maxDigits = Math.ceil(frac.number.bitCount() / Math.log(10));
            var afterStr = '';
            var ten = BigReal.fromFloat(10);
            for (var i = 0; i < maxDigits; i++) {
                var parts = frac.mul(ten).wholeFrac();
                frac = parts.frac;
                afterStr += parts.whole.number.toString();
                if (frac.isEqual(BigReal.zero)) break;
            }
        
            result = whole.number.toString() + '.' + afterStr;
        });
        return result;
    }
    
    /** Good old TRIG **/
    
    BigReal.piString = '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218';
    
    BigReal.prototype.circlePeriod = function() {
        var scaled = this.div(BigReal.fromString(BigReal.piString)).div(BigReal.fromFloat(2));
        if (scaled.number.sign) {
            // positive
            return scaled.wholeFrac().frac;
        } else {
            // negative
            return scaled.wholeFrac().frac.add(BigReal.fromFloat(1));
        }
    }
    
    BigReal.prototype.sin = function() {
        var period = this.circlePeriod();
        var quarter = BigReal.fromFloat(1/4);
        var quadrant = Math.round(period.div(quarter).wholeFrac().whole.toFloat());
        if (quadrant == 0) {
            return period.firstQuadVector()[1];
        } else if (quadrant == 1) {
            return period.sub(quarter).firstQuadVector()[0];
        } else if (quadrant == 2) {
            return period.sub(BigReal.fromFloat(1/2)).firstQuadVector()[1].neg();
        } else {
            return period.sub(BigReal.fromFloat(3/4)).firstQuadVector()[0].neg();
        }
    }
    
    BigReal.prototype.cos = function() {
        var period = this.circlePeriod();
        var quarter = BigReal.fromFloat(1/4);
        var quadrant = Math.round(period.div(quarter).wholeFrac().whole.toFloat());
        if (quadrant == 0) {
            return period.firstQuadVector()[0];
        } else if (quadrant == 1) {
            return period.sub(quarter).firstQuadVector()[1].neg();
        } else if (quadrant == 2) {
            return period.sub(BigReal.fromFloat(1/2)).firstQuadVector()[0].neg();
        } else {
            return period.sub(BigReal.fromFloat(3/4)).firstQuadVector()[1];
        }
    }
    
    BigReal.prototype.tan = function() {
        var period = this.circlePeriod();
        var quarter = BigReal.fromFloat(1/4);
        var quadrant = Math.round(period.div(quarter).wholeFrac().whole.toFloat());
        if (quadrant == 1) period = period.sub(quarter);
        if (quadrant == 2) period = period.sub(BigReal.fromFloat(1/2));
        if (quadrant == 3) period = period.sub(BigReal.fromFloat(3/4));
        var result = period.firstQuadVector();
        if (quadrant % 2 == 0) return result[1].div(result[0]);
        return result[0].div(result[1]).neg();
    }
    
    BigReal.prototype.firstQuadVector = function() {
        // TODO: assert our range: 0 <= this <= 0.25
        var lower = BigReal.zero;
        var upper = BigReal.fromFloat(0.25);
        var two = BigReal.fromFloat(2);
        
        var v1 = [BigReal.fromFloat(1), BigReal.zero];
        var v2 = [v1[1], v1[0]];
        for (var i = 0; i < BigReal.precision; i++) {
            var midVector = [v1[0].add(v2[0]), v1[1].add(v2[1])];
            var mag = midVector[0].mul(midVector[0]).add(midVector[1].mul(midVector[1])).sqrt();
            midVector = [midVector[0].div(mag), midVector[1].div(mag)];
            var curX = lower.add(upper).div(two);
            if (curX.isGreater(this)) {
                upper = curX;
                v2 = midVector;
            } else {
                lower = curX;
                v1 = midVector;
            }
        }
        
        return v1;
    }
    
    return BigReal;
})();

var BigReal = br;
if (module) {
    module.exports = BigReal;
}