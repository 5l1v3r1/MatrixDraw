if (typeof numeric == 'undefined') {
    if (require) {
        numeric = require('./numeric.js');
    } else {
        numeric = window.numeric;
    }
}

if (typeof ANMatrix == 'undefined') {
    ANMatrix = require('./base.js');
}

ANMatrix.Matrix.prototype.to2DArray = function() {
    // generate the silly format for numeric
    var rowsList = [];
    for (var i = 0; i < this.rows; i++) {
        var aRow = [];
        for (var j = 0; j < this.cols; j++) {
            aRow.push(this.getAt(i, j).re);
        }
        rowsList.push(aRow);
    }
    return rowsList;
}

ANMatrix.Matrix.prototype.diagonalize = function() {
    if (this.rows != this.cols) {
        throw new Error('matrix must be square to diagonalize');
    }
    var size = this.rows;
    
    // create eigenvectors matrix
    var rowList = this.to2DArray();
    var eig = numeric.eig(rowList);
    var aMat = eig.E;
    var data = [];
    for (var row = 0; row < size; row++) {
        for (var col = 0; col < size; col++) {
            var re = aMat.x[row][col];
            var im = aMat.y ? aMat.y[row][col] : 0;
            data.push(new ANMatrix.Complex(re, im));
        }
    }
    var eigMat = new ANMatrix.Matrix(data, size, size);
    var eigInv = eigMat.inverse();
    if (!eigInv) return null; // needs Jordan decomp.
    
    // create diagonal eigenvalues matrix
    var eigValues = ANMatrix.Matrix.zeros(size, size);
    for (var i = 0; i < size; i++) {
        var re = eig.lambda.x[i];
        var im = eig.lambda.y ? eig.lambda.y[i] : 0;
        eigValues.setAt(i, i, new ANMatrix.Complex(re, im));
    }
    
    return {S: eigMat, V: eigValues, Sinv: eigInv};
}

/**
 * Returns an array of Complex eigenvalues.
 * This is rather counterintuitive, because this
 * method can only be called on real matrices.
 * The fact of the matter is, I'm too lazy to fix it.
 */
ANMatrix.Matrix.prototype.eig = function() {
    if (this.rows != this.cols) {
        throw new Error('matrix must be square to take eigenvalues');
    }
    
    // special cases with extra precision; not really :,(
    if (this.rows == 2) return this.quadraticEig();
    if (this.rows == 3) return this.cubicEig();
    
    var rowList = this.to2DArray();
    var lambda = numeric.eig(rowList).lambda;
    
    // create a list of non-repeating complex numbers
    var list = [];
    for (var i = 0; i < lambda.x.length; i++) {
        var nextEig = new ANMatrix.Complex(lambda.x[i], lambda.y ? lambda.y[i] : 0);
        // make sure it's not already there
        for (var j = 0; j < list.length; j++) {
            var anEig = list[j];
            if (anEig.sub(nextEig).isSmall()) {
                nextEig = null;
            }
        }
        if (nextEig) list.push(nextEig.multiply(1));
    }
    
    return list;
}

ANMatrix.Matrix.prototype.quadraticEig = function() {
    var a = new ANMatrix.Complex(1);
    var b = this.data[3].add(this.data[0]).mul(-1);
    var c = this.determinant();
    var delta = b.pow(2).sub(c.mul(a).mul(4));
    var rootDelta = delta.pow(1/2);
    if (rootDelta.isSmall()) return [b.mul(-1).div(a.mul(2))];
    var val1 = b.add(rootDelta);
    var val2 = b.sub(rootDelta);
    return [val1.div(a.mul(2)), val2.div(a.mul(2))];
}

ANMatrix.Matrix.prototype.cubicEig = function() {
    // compute the coefficients of the third-degree characteristic
    // polynomial; thanks, wolfram!
    var a = new ANMatrix.Complex(-1);
    var b = this.getAt(0, 0).add(this.getAt(1, 1)).add(this.getAt(2, 2));
    var c = new ANMatrix.Complex(0);
    var d = this.determinant();
    c = c.add(this.data[1].mul(this.data[3]));
    c = c.add(this.data[2].mul(this.data[6]));
    c = c.add(this.data[5].mul(this.data[7]));
    c = c.sub(this.getAt(0, 0).mul(this.getAt(1, 1)));
    c = c.sub(this.getAt(1, 1).mul(this.getAt(2, 2)));
    c = c.sub(this.getAt(0, 0).mul(this.getAt(2, 2)));
        
    // the cubic formula is my bitch.
    var delta = a.mul(b).mul(c).mul(d).mul(18);
    delta = delta.sub(b.pow(3).mul(d).mul(4));
    delta = delta.add(b.mul(c).pow(2));
    delta = delta.sub(c.pow(3).mul(a).mul(4));
    delta = delta.sub(a.mul(d).pow(2).mul(27));
    var delta0 = b.pow(2).sub(a.mul(c).mul(3));
    var delta1 = b.pow(3).mul(2).sub(a.mul(b).mul(c).mul(9));
    delta1 = delta1.add(a.pow(2).mul(d).mul(27));
    
    var C = delta1.add(delta1.pow(2).sub(delta0.pow(3).mul(4)).pow(1/2));
    C = C.div(2).pow(1/3);
    
    // calculate three roots with three phase changes
    var uVals = [new ANMatrix.Complex(1),
                 new ANMatrix.Complex(-1/2, Math.sqrt(3)/2),
                 new ANMatrix.Complex(-1/2, -Math.sqrt(3)/2)];
    var roots = [];
    for (var i = 0; i < 3; i++) {
        var u = uVals[i];
        var root = b.add(u.mul(C)).add(delta0.div(u.mul(C)));
        root = root.mul(a.inv().mul(-1/3));
        for (var j = 0; j < roots.length; j++) {
            if (roots[j].sub(root).isSmall()) {
                root = null;
                break;
            }
        }
        if (!root) continue;
        roots.push(root.fix(6));
    }
    
    return roots;
}
