if (typeof ANMatrix == 'undefined') {
    ANMatrix = require('./base.js');
}

if (typeof BigReal == 'undefined') {
    BigReal = require('dynum').BigReal;
}

ANMatrix.Matrix.prototype.to2DArray = function() {
    // generate the silly format for numeric
    var rowsList = [];
    for (var i = 0; i < this.rows; i++) {
        var aRow = [];
        for (var j = 0; j < this.cols; j++) {
            aRow.push(this.getAt(i, j).re.toFloat());
        }
        rowsList.push(aRow);
    }
    return rowsList;
}

ANMatrix.Matrix.prototype.diagonalize = function() {
    throw new Error('NYI');
}

/**
 * Returns an array of Complex eigenvalues.
 * This is rather counterintuitive, because this
 * method can only be called on real matrices.
 * The fact of the matter is, I'm too lazy to fix it.
 */
ANMatrix.Matrix.prototype.eig = function() {
    if (this.rows != this.cols) {
        throw new Error('matrix must be square to take eigenvalues');
    }
    
    // special cases with extra precision; not really :,(
    if (this.rows == 2) return this.quadraticEig();
    if (this.rows == 3) return this.cubicEig();
    throw new Error('NYI');
}

ANMatrix.Matrix.prototype.quadraticEig = function() {
    var a = new ANMatrix.Complex(1);
    var b = this.data[3].add(this.data[0]).mul(-1);
    var c = this.determinant();
    var delta = b.pow(2).sub(c.mul(a).mul(4));
    var rootDelta = delta.sqrt();
    if (rootDelta.isSmall()) return [b.mul(-1).div(a.mul(2))];
    var val1 = b.add(rootDelta);
    var val2 = b.sub(rootDelta);
    return [val1.div(a.mul(2)), val2.div(a.mul(2))];
}

ANMatrix.Matrix.prototype.cubicEig = function() {
    // compute the coefficients of the third-degree characteristic
    // polynomial; thanks, wolfram!
    var a = new ANMatrix.Complex(-1);
    var b = this.getAt(0, 0).add(this.getAt(1, 1)).add(this.getAt(2, 2));
    var c = new ANMatrix.Complex(0);
    var d = this.determinant();
    c = c.add(this.data[1].mul(this.data[3]));
    c = c.add(this.data[2].mul(this.data[6]));
    c = c.add(this.data[5].mul(this.data[7]));
    c = c.sub(this.getAt(0, 0).mul(this.getAt(1, 1)));
    c = c.sub(this.getAt(1, 1).mul(this.getAt(2, 2)));
    c = c.sub(this.getAt(0, 0).mul(this.getAt(2, 2)));
    
    console.log(a + ' ' + b + ' ' + c + ' ' + d);
    
    // the cubic formula is my bitch.
    var delta = a.mul(b).mul(c).mul(d).mul(18);
    delta = delta.sub(b.pow(3).mul(d).mul(4));
    delta = delta.add(b.mul(c).pow(2));
    delta = delta.sub(c.pow(3).mul(a).mul(4));
    delta = delta.sub(a.mul(d).pow(2).mul(27));
    var delta0 = b.pow(2).sub(a.mul(c).mul(3));
    var delta1 = b.pow(3).mul(2).sub(a.mul(b).mul(c).mul(9));
    delta1 = delta1.add(a.pow(2).mul(d).mul(27));
    
    var C = delta1.add(delta1.pow(2).sub(delta0.pow(3).mul(4)).sqrt());
    C = C.div(2).cbrt();
    
    // calculate three roots with three phase changes
    var uVals = [new ANMatrix.Complex(1),
                 new ANMatrix.Complex(-1/2, BigReal.fromFloat(3/4).sqrt()),
                 new ANMatrix.Complex(-1/2, BigReal.fromFloat(3/4).sqrt().neg())];
    var roots = [];
    var epsilon = BigReal.epsilon();
    for (var i = 0; i < 3; i++) {
        var u = uVals[i];
        var root = b.add(u.mul(C)).add(delta0.div(u.mul(C)));
        root = root.mul(a.inv().mul(-1/3));
        for (var j = 0; j < roots.length; j++) {
            if (roots[j].sub(root).isSmall()) {
                root = null;
                break;
            }
        }
        if (!root) continue;
        console.log('eigenvalue ' + root);
        roots.push(root);
    }
    
    return roots;
}
