if (typeof ANMatrix == 'undefined') {
    ANMatrix = require('./base.js');
}

ANMatrix.Matrix.exchange = function(size, row1, row2) {
    var mat = ANMatrix.Matrix.zeros(size, size);
    for (var i = 0; i < size; i++) {
        var workingRow = i == row1 ? row2 : (i == row2 ? row1 : i);
        mat.data[workingRow + (workingRow * size)] = new ANMatrix.Complex(1);
    }
    return mat;
}

/**
 * Returns an object {L: Matrix, U: Matrix, rank: Number}.
 */
ANMatrix.Matrix.prototype.eliminate = function() {
    var working = this;
    var pivotsDone = 0;
    var rank = 0;
    var transform = ANMatrix.Matrix.identity(this.rows);
    
    for (var col = 0; col < this.cols && pivotsDone < this.rows; col++) {
        var pivotRow = -1;
        for (var rowCheck = pivotsDone; rowCheck < this.rows; rowCheck++) {
            if (!working.getAt(rowCheck, col).isSmall()) {
                pivotRow = rowCheck;
                break;
            }
        }
        if (pivotRow < 0) continue;
        if (pivotRow != pivotsDone) {
            // row exchange is necessary
            var exchange = ANMatrix.Matrix.exchange(this.rows, pivotsDone, pivotRow);
            working = exchange.multiply(working);
            transform = exchange.multiply(transform);
        }
        
        // create an elimination matrix
        var eliminator = ANMatrix.Matrix.identity(this.rows);
        var pivotValue = working.getAt(pivotsDone, col);
        for (var reduceRow = pivotsDone + 1; reduceRow < this.rows; reduceRow++) {
            // supply the elimination coefficient
            var coeff = working.getAt(reduceRow, col).div(pivotValue);
            eliminator.setAt(reduceRow, pivotsDone, coeff.mul(-1));
        }

        transform = eliminator.multiply(transform);
        working = eliminator.multiply(working);

        pivotsDone += 1;
        rank += 1;
    }
    
    return {L: transform, U: working, rank: rank};
}

/**
 * Reduces the matrix to row-reduced echelon form.
 * This will allow us to find the nullspace in a jiffy.
 */
ANMatrix.Matrix.prototype.rref = function() {
    var result = this.eliminate();
    var working = result.U;
    var transform = result.L;
    for (var row = this.rows - 1; row >= 0; row--) {
        var pivotColumn = -1;
        for (var i = 0; i < this.cols; i++) {
            if (!working.getAt(row, i).isSmall()) {
                pivotColumn = i;
                break;
            }
        }
        if (pivotColumn < 0) continue;
    
        var pivotValue = working.getAt(row, pivotColumn);
        var deduceMatrix = ANMatrix.Matrix.identity(this.rows);
        for (var i = row - 1; i >= 0; i--) {
            var columnValue = working.getAt(i, pivotColumn);
            var reduceScale = columnValue.div(pivotValue);
            deduceMatrix.setAt(i, row, reduceScale.mul(-1));
        }
        deduceMatrix.setAt(row, pivotColumn, pivotValue.inv());
        transform = deduceMatrix.multiply(transform);
        working = deduceMatrix.multiply(working);
    }

    return {rref: working, transform: transform, rank: result.rank};
}

ANMatrix.Matrix.prototype.inverse = function() {
    if (this.rows != this.cols) {
        throw new Error('dimensions mismatch');
    }
    var result = this.rref();
    if (result.rank != this.cols) {
        return null;
    }
    return result.transform;
}

/**
 * Finds a basis for the nullspace
 */
ANMatrix.Matrix.prototype.nullSpace = function() {
    var result = this.rref();
    var rref = result.rref;
    var rank = result.rank;
    if (rank == 0) return this;
    if (rank == this.cols) return null;
        
    // find all the pivot columns to distinguish our free variables
    var columnTypes = new Array(this.cols);
    for (var i = 0; i < this.rows; i++) {
        for (var col = 0; col < this.cols; col++) {
            if (!rref.getAt(i, col).isSmall()) {
                columnTypes[col] = true;
                break;
            }
        }
    }
    
    // generate the nullspace basis
    var nullspace = ANMatrix.Matrix.zeros(this.cols, this.cols - rank);
    var vectorIndex = 0;
    for (var freeVar = 0; freeVar < this.cols; freeVar++) {
        if (columnTypes[freeVar]) continue;
        
        // decidedValues indicates which columns we've already
        // taken into account to calculate our vector
        var decidedValues = [];
        for (var i = 0; i < this.cols; i++) {
            decidedValues[i] = false;
        }
        decidedValues[freeVar] = true;
        nullspace.setAt(freeVar, vectorIndex, new ANMatrix.Complex(1));
        
        // go bottom up and figure out the values one by one
        for (var i = this.rows - 1; i >= 0; i--) {
            var decidedSum = new ANMatrix.Complex(0);
            for (var j = 0; j < this.cols; j++) {
                if (!decidedValues[j]) continue;
                var val1 = nullspace.getAt(j, vectorIndex);
                var val2 = rref.getAt(i, j);
                decidedSum = decidedSum.add(val1.mul(val2));
            }
            var undecidedIndex = -1;
            for (var j = 0; j < this.cols; j++) {
                if (decidedValues[j]) continue;
                if (!rref.getAt(i, j).isSmall()) {
                    undecidedIndex = j;
                    break;
                }
            }
            if (undecidedIndex < 0) continue;
            var killValue = rref.getAt(i, undecidedIndex);
            var coeff = decidedSum.div(killValue).mul(-1);
            nullspace.setAt(undecidedIndex, vectorIndex, coeff);
            decidedValues[undecidedIndex] = true;
        }
        
        vectorIndex++;
    }
    
    return nullspace;
}

ANMatrix.Matrix.prototype.columnSpace = function() {
    var result = this.rref();
    var rref = result.rref;
    var rank = result.rank;
    if (rank == 0) return null;
    if (rank == this.cols) return this;
        
    // find all the pivot columns to distinguish our free variables
    var columnTypes = new Array(this.cols);
    for (var i = 0; i < this.rows; i++) {
        for (var col = 0; col < this.cols; col++) {
            if (!rref.getAt(i, col).isSmall()) {
                columnTypes[col] = true;
                break;
            }
        }
    }
    
    // our pivot columns give a basis
    var basis = ANMatrix.Matrix.zeros(this.rows, rank);
    var vectorIndex = 0;
    for (var i = 0; i < this.cols; i++) {
        if (!columnTypes[i]) continue;
        for (var j = 0; j < this.rows; j++) {
            basis.setAt(j, vectorIndex, this.getAt(j, i));
        }
        vectorIndex++;
    }
    
    return {basis: basis, pivots: columnTypes};
}

ANMatrix.Matrix.prototype.pseudoSolve = function(result) {
    if (result.cols != 1) {
        throw new Error('invalid result size');
    }
    var colResult = this.columnSpace();
    var colSpace = colResult.basis;
        
    var leftMat = colSpace.transpose().multiply(colSpace);
    var rightVec = colSpace.transpose().multiply(result);
        
    var smallResult = leftMat.inverse().multiply(rightVec);
    
    // turn smallResult into a "big" result
    var bigResult = ANMatrix.Matrix.zeros(this.rows, 1);
    var smallIndex = 0;
    for (var i = 0; i < this.rows; i++) {
        if (!colResult.pivots[i]) continue;
        bigResult.setAt(i, 0, smallResult.getAt(smallIndex, 0));
        smallIndex++;
    }
    
    return bigResult;
}

ANMatrix.Matrix.prototype.determinant = function() {
    if (this.rows != this.cols) {
        throw new Error('matrix must be square to take det(A)');
    }
    var result = this.eliminate();
    if (this.rows != result.rank) return 0;
    // take product of diagonal
    var det = new ANMatrix.Complex(1);
    for (var i = 0; i < this.rows; i++) {
        det = det.mul(result.U.getAt(i, i));
    }
    return det;
}
