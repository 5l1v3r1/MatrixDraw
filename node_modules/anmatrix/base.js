var ANMatrix = (function () {
    if (!BigReal) {
        BigReal = require('dynum').BigReal;
    }
    
    /**
     * Immutable complex number type.
     */
    function Complex(re, im) {
        this.re = re || BigReal.zero;
        this.im = im || BigReal.zero;
    }

    Complex.prototype.abs = function() {
        var mag = this.re.mul(this.re) + this.im.mul(this.im);
        return mag.sqrt();
    }

    Complex.prototype.phase = function() {
        // TODO: better atan2 method
        var angle = Math.atan2(this.im.toFloat(), this.re.toFloat());
        return BigReal.fromFloat(angle);
    }

    Complex.prototype.conjugate = function() {
        return new Complex(this.re, this.im.neg());
    }

    Complex.prototype.add = function(aNum) {
        if (typeof aNum == 'number') {
            return new Complex(this.re.add(BigReal.withFloat(aNum)), this.im);
        } else {
            if (aNum instanceof BigReal) {
                return new Complex(this.re.add(aNum), this.im);
            } else {
                return new Complex(this.re.add(aNum.re), this.im.add(aNum.im));
            }
        }
    }
    
    Complex.prototype.sub = function(aNum) {
        if (typeof aNum == 'number') {
            return new Complex(this.re.sub(BigReal.withFloat(aNum)), this.im);
        } else {
            if (aNum instanceof BigReal) {
                return new Complex(this.re.sub(aNum), this.im);
            } else {
                return new Complex(this.re.sub(aNum.re), this.im.sub(aNum.im));
            }
        }
    }

    Complex.prototype.mul = function(aNum) {
        if (typeof aNum == 'number') {
            var numObj = BigReal.withFloat(aNum);
            return new Complex(this.re.mul(numObj), this.im.mul(numObj));
        } else {
            if (numObj instanceof BigReal) {
                return new Complex(this.re.mul(aNum), this.im.mul(aNum));
            } else {
                return new Complex(this.re.mul(aNum.re).sub(this.im.mul(aNum.im)),
                                   this.re.mul(aNum.im).add(this.im.mul(aNum.re));
            }
        }
    }
    
    Complex.prototype.div = function(denom) {
        if (typeof denom == 'number') return this.mul(1 / denom);
        if (denom instanceof BigReal) {
            return new Complex(this.re.div(denom), this.im.div(denom));
        } else {
            return this.mul(denom.inv());
        }
    }

    Complex.prototype.inv = function() {
        var mag = this.re.mul(this.re) + this.im.mul(this.im);
        var re = this.re.div(mag);
        var im = -this.im.div(mag);
        return new Complex(re, im);
    }
    
    Complex.prototype.pow = function(power) {
        // TODO: write a correct implementation of this
        var mag = Math.pow(this.abs(), power);
        var phase = this.phase() * power;
        return new Complex(mag * Math.cos(phase), mag * Math.sin(phase));
    }
    
    Complex.prototype.isSmall = function() {
        return this.abs() < Math.pow(10, -Complex.precision);
    }
    
    Complex.prototype.toString = function() {
        if (this.im > 0) {
            return this.re + ' + i*' + this.im;
        }
        return this.re.toString();
    }

    Complex.precision = 5;

    /**
     * Immutable complex valued matrix.
     */
    function Matrix(data, rows, columns) {
        this.data = data;
        this.rows = rows;
        this.cols = columns;
    }

    Matrix.zeros = function(rows, cols) {
        var data = [];
        for (var i = 0; i < rows * cols; i++) {
            data.push(new Complex(0));
        }
        return new Matrix(data, rows, cols);
    }

    Matrix.identity = function(size) {
        var mat = Matrix.zeros(size, size);
        for (var i = 0; i < size; i++) {
            mat.data[i + (i * size)] = new Complex(1);
        }
        return mat;
    }

    Matrix.prototype.copy = function() {
        var newData = [];
        for (var i = 0; i < this.data.length; i++) {
            newData[i] = this.data[i];
        }
        return new Matrix(newData, this.rows, this.cols);
    }

    Matrix.prototype.getAt = function(row, col) {
        return this.data[col + (row * this.cols)];
    }

    /**
     * Multiplies `this` on the left of aMat.
     */
    Matrix.prototype.multiply = function(aMat) {
        if (this.cols != aMat.rows) {
            throw new Error('left.cols != right.rows');
        }
    
        // multiply two complex matrices
        var rows = this.rows;
        var cols = aMat.cols;
        var data = new Array(rows * cols);
        var index = 0;
        for (var row = 0; row < rows; row++) {
            for (var col = 0; col < cols; col++) {
                data[index] = new Complex();
                for (var i = 0; i < this.cols; i++) {
                    var myValue = this.getAt(row, i);
                    var aValue = aMat.getAt(i, col);
                    data[index] = data[index].add(myValue.mul(aValue));
                }
                index++;
            }
        }
        return new Matrix(data, rows, cols);
    }

    Matrix.prototype.add = function(aMat) {
        if (aMat.rows != this.rows || aMat.cols != this.cols) {
            throw new Error('dimension mismatch');
        }
        var newData = [];
        for (var i = 0; i < this.data.length; i++) {
            newData[i] = this.data[i].add(aMat.data[i]);
        }
        return new Matrix(newData, this.rows, this.cols);
    }
    
    Matrix.prototype.scale = function(_scalar) {
        var scalar = typeof _scalar == 'number' ? new Complex(_scalar) : _scalar;
        var newData = [];
        for (var i = 0; i < this.data.length; i++) {
            newData[i] = this.data[i].mul(scalar);
        }
        return new Matrix(newData, this.rows, this.cols);
    }
    
    Matrix.prototype.transpose = function() {
        var newMat = Matrix.zeros(this.cols, this.rows);
        for (var row = 0; row < this.rows; row++) {
            for (var col = 0; col < this.cols; col++) {
                newMat.setAt(col, row, this.getAt(row, col).conjugate());
            }
        }
        return newMat;
    }
    
    Matrix.prototype.subMatrix = function(row, col, rows, cols) {
        if (row + rows > this.rows) throw new Error('rows out of bounds');
        if (col + cols > this.cols) throw new Error('cols out of bounds');
        var newMat = Matrix.zeros(rows, cols);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                newMat.setAt(i, j, this.getAt(i + row, j + col));
            }
        }
        return newMat;
    }
    
    Matrix.prototype.copyInto = function(aMat, row, col) {
        if (row + aMat.rows > this.rows) throw new Error('row out of bounds');
        if (col + aMat.cols > this.cols) throw new Error('col out of bounds');
        var result = this.copy();
        for (var i = 0; i < aMat.rows; i++) {
            for (var j = 0; j < aMat.cols; j++) {
                result.setAt(i + row, j + col, aMat.getAt(i, j));
            }
        }
        return result;
    }
    
    Matrix.prototype.toString = function() {
        var str = '[';
        for (var row = 0; row < this.rows; row++) {
            if (row != 0) str += '; ';
            for (var col = 0; col < this.cols; col++) {
                if (col != 0) str += ' ';
                str += this.getAt(row, col).toString();
            }
        }
        return str + ']';
    }
    
    /**
     * Private: do not call this!
     */
    Matrix.prototype.setAt = function(row, col, val) {
        this.data[col + (row * this.cols)] = val;
    }
    
    // return the exports
    return {Matrix: Matrix, Complex: Complex};
})();

if (module) {
    module.exports = ANMatrix;
} else {
    window.ANMatrix = ANMatrix;
}
