if (typeof ANMatrix == 'undefined') {
    ANMatrix = require('./base.js');
}

if (typeof BigReal == 'undefined') {
    BigReal = require('dynum').BigReal;
}

ANMatrix.JordanChain = function(origMat, curMat, vector) {
    this.origMat = origMat;
    this.curMat = curMat;
    this.vector = vector;
}

ANMatrix.JordanChain.prototype.next = function() {
    var nextMat = this.curMat.multiply(this.origMat);
    
    // make sure there's another link in the chain
    var rank = this.curMat.eliminate().rank;
    var nextRank = nextMat.eliminate().rank;
    if (nextRank == rank) return null;
    
    var nextVec = this.curMat.pseudoSolve(this.vector);
    
    // verify that it is indeed a solution
    var test = this.curMat.multiply(nextVec);
    var diffVec = test.add(this.vector.scale(-1));
    for (var i = 0; i < diffVec.data.length; i++) {
        if (!diffVec.data[i].isSmall()) return null;
    }
    
    return new ANMatrix.JordanChain(this.origMat, nextMat, nextVec);
}

ANMatrix.JordanBlock = function(lambda, chain) {
    this.vectors = [];
    this.eigVal = lambda;
    var aChain = chain;
    while (aChain) {
        this.vectors.push(aChain.vector);
        aChain = aChain.next();
    }
}

ANMatrix.JordanBlock.forEig = function(matrix, eigVal) {
    if (matrix.rows != matrix.cols) {
        throw new Error('matrix must be square');
    }
        
    var lambdaI = ANMatrix.Matrix.identity(matrix.rows).scale(eigVal.mul(-1));
    var orig = matrix.add(lambdaI);
    
    var nullSpace = orig.nullSpace();
    var blocks = [];
    for (var i = 0; i < nullSpace.cols; i++) {
        var eigenVector = nullSpace.subMatrix(0, i, nullSpace.rows, 1);
        var chainHead = new ANMatrix.JordanChain(orig, orig, eigenVector);
        var block = new ANMatrix.JordanBlock(eigVal, chainHead);
        blocks.push(block);
    }
    
    return blocks;
}

/**
 * Could easily throw an exception if the matrix
 * is unstable under the current level of precision.
 */
ANMatrix.Matrix.prototype.jordanUnsafe = function() {
    if (this.rows != this.cols) {
        throw new Error('matrix must be square');
    }
    
    var eig = null;
    var thisRef = this;
    BigReal.withDouble(function() {
        eig = thisRef.eig();
    });
    var blocks = [];
    for (var i = 0; i < eig.length; i++) {
        blocks = blocks.concat(ANMatrix.JordanBlock.forEig(this, eig[i]));
    }
    
    // generate our P & J!
    var P = ANMatrix.Matrix.zeros(this.rows, this.cols);
    var J = P.copy();
    var vectorIndex = 0;
    for (var i = 0; i < blocks.length; i++) {
        var aBlock = blocks[i];
        for (var j = 0; j < aBlock.vectors.length; j++) {
            P = P.copyInto(aBlock.vectors[j], 0, vectorIndex);
            J.setAt(vectorIndex, vectorIndex, aBlock.eigVal);
            if (j < aBlock.vectors.length - 1) {
                J.setAt(vectorIndex, vectorIndex + 1, new ANMatrix.Complex(1));
            }
            vectorIndex++;
        }
    }
    if (vectorIndex != this.rows) throw new Error('internal inconsistency: too few vectors');
    var Pinv = P.inverse();
    if (!Pinv) throw new Error('same eigenvalue passed twice as different thing.');
    return {P: P, J: J, Pinv: Pinv};
}

ANMatrix.Matrix.prototype.jordan = function() {
    // try all levels of precision
    var prec = BigReal.precision * 2;
    var retVal = null;
    try {
        var jordan = this.jordanUnsafe();
        retVal = jordan;
    } catch (e) {}
    return retVal;
}
